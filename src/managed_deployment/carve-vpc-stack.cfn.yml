AWSTemplateFormatVersion: '2010-09-09'
Description: Carve VPC Testing Beacons

Parameters:
  VpcId:
    Type: String
    Description: VPC ID in which the beacons should be created
    Default: ""
  VpcSubnetIds:
    Type: String
    Description: one or more comma separated subnets in which to create beacons
    Default: ""
  Prefix:
    Type: String
    Description: "Prefix carve AWS resources and stacknames with this"
    Default: ""
  ImageId:
    Type: String
    Description: The ImageId from the Carve imagebuilder
    Default: ''
  CarveSNSTopicArn:
    Type: String
    Description: Carve SNS Topic
  CarveCoreRegion:
    Type: String
    Description: Region where Carve Core is running
  MinSize:
    Description: Minimum number of instances in the ASG
    Type: Number
    Default: '0'
  MaxSize:
    Description: Maximum number of instances in the ASG
    Type: Number
    Default: '1'
  DesiredSize:
    Description: Desored number of instances in the ASG
    Type: Number
    Default: '1'
  PublicIPs:
    Description: Assign Public IPs to Instances
    Default: 'false'

# Conditions:
#   UseOrgId: !Equals 
#     - !Ref "UniqueId"
#     - !Ref ""

Resources:
  BridgeFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${Prefix}carve-bridge-${VpcId}'
      Description: Bridge ASG Events Across Accounts and Regions with SNS
      Handler: index.lambda_handler
      Role: !GetAtt CarveLambdaRole.Arn
      Runtime: python3.8
      Timeout: 20
      MemorySize: 128
      Code: 
        ZipFile: !Sub |
          import boto3, os, json
          def lambda_handler(event, context):
              print(event)
              if 'source' in event:
                  if event['source'] == 'aws.autoscaling':
                      client = boto3.client('sns', region_name="${CarveCoreRegion}")
                      response = client.publish(
                          TopicArn="${CarveSNSTopicArn}",
                          Message=json.dumps(event))

  SubnetFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CarveSubnetFunction
      Description: Continuous AWS Route Verification Engine
      Handler: index.lambda_handler
      Role: !GetAtt CarveLambdaRole.Arn
      Runtime: python3.8
      Timeout: 20
      MemorySize: 128
      Environment:
        Variables:
          VpcSubnetIds: !Ref VpcSubnetIds
          VpcId: !Ref VpcId
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds: !Split [ ",", !Ref VpcSubnetIds ]
      Code: 
        ZipFile: !Sub |
          import urllib3
          import socket
          import json

          def hc(beacon):
              http = urllib3.PoolManager()
              try:
                  r = http.request('GET', f'http://{beacon}/up', timeout=0.1)
                  if r.status == 200:
                      result = 'up'
                  else:
                      result = 'down'
              except:
                  result = 'down'
              return result

          def get_results(beacon):
              print(f'getting results for beacon: {beacon}')
              http = urllib3.PoolManager()
              result = None
              try:
                  r = http.request('GET', f'http://{beacon}/results', timeout=0.1)
                  ts = http.request('GET', f'http://{beacon}/ts', timeout=0.1)
                  if r.status == 200:
                      result = {'status': r.status, 'result': r.data, 'health': hc(beacon), 'ts': ts.data}
                  else:
                      result = {'status': r.status, 'result': 'error', 'health': hc(beacon)}
              except urllib3.exceptions.ConnectTimeoutError:
                  result = {'status': 'ConnectTimeoutError', 'result': 'timeout', 'health': hc(beacon)}
              except urllib3.exceptions.MaxRetryError:
                  result = {'status': 'MaxRetryError', 'result': 'timeout', 'health': hc(beacon)}
              except urllib3.exceptions.HTTPError as e:
                  result = {'status': 'HTTPError', 'result': 'timeout', 'health': hc(beacon)}
              print(result)
              return result

          def update_beacon(beacon, beacons):
              config = json.dumps({'beacons': beacons}).encode()
              with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                  s.connect((beacon, 8008))
                  s.sendall(config)
                  data = s.recv(1024)
              if data == config:
                  print('beacon update successful')
              else:
                  print(f'ERROR: beacon update confirmation failed for {beacon}')
                  print(f'submitted: {config}')
                  print(f'returned: {data}')

          def lambda_handler(event, context):
              print(event)
              if event['action'] == 'results':
                  result = get_results(event['beacon'])
              elif event['action'] == 'update':
                  result = update_beacon(event['beacon'], event['beacons'])
              return result


  CarveLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal:
            Service:
              - "lambda.amazonaws.com"
          Action:
            - "sts:AssumeRole"
      Policies:
        - PolicyName: CarveSNS
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "sns:Publish"
                Resource: !Ref CarveSNSTopicArn


  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Carve Lambda Egress

  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    CreationPolicy:
      ResourceSignal:
        Timeout: PT5M
        Count: !Ref MinSize
    Properties:
      AutoScalingGroupName: !Sub ${Prefix}carve-beacon-asg-${VpcId}
      LaunchConfigurationName: !Ref LaunchConfig
      VPCZoneIdentifier: !Split [ ",", !Ref VpcSubnetIds ]
      HealthCheckGracePeriod: '60'
      HealthCheckType: EC2
      MinSize: !Ref MinSize
      MaxSize: !Ref MaxSize
      MetricsCollection:
        - Granularity: 1Minute
      Tags:
        - Key: Name
          Value: !Sub ${Prefix}carve-beacon-${VpcId}
          PropagateAtLaunch: true

  LaunchConfig:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      AssociatePublicIpAddress: !Ref PublicIPs
      SecurityGroups:
        - !Ref 'InstanceSecurityGroup'
      IamInstanceProfile: !Ref 'InstanceProfile'
      ImageId: !Ref 'ImageId'
      InstanceMonitoring: 'false'
      InstanceType: t4g.nano
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeType: gp2
            VolumeSize: '8'
            DeleteOnTermination: 'true'
            Encrypted: 'true'
      UserData:
        "Fn::Base64":
          !Sub |
            #!/bin/bash -xe
            # Start cfn-init
            # /opt/aws/bin/cfn-init -s ${AWS::StackId} -r LaunchConfig --region ${AWS::Region} || error_exit 'Failed to run cfn-init'
            # Start up the cfn-hup daemon to listen for changes to the EC2 instance metadata
            # /opt/aws/bin/cfn-hup || error_exit 'Failed to start cfn-hup'
            mkdir /carve/
            echo "0.0.0.0" > /carve/carve.cfg
            echo "import os" > /carve/updater.py
            echo "import socket" >> /carve/updater.py
            echo "import json" >> /carve/updater.py
            echo "import ipaddress" >> /carve/updater.py
            echo "" >> /carve/updater.py
            echo "'''" >> /carve/updater.py
            echo "Basic socket server to receive data on port 8008" >> /carve/updater.py
            echo "It is used to update the carve config beacon data" >> /carve/updater.py
            echo "Data must be submitted as byte encoded valid json" >> /carve/updater.py
            echo "'''" >> /carve/updater.py
            echo "" >> /carve/updater.py
            echo "def socket_server():" >> /carve/updater.py
            echo "    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:" >> /carve/updater.py
            echo "        s.bind(('0.0.0.0', 8008))" >> /carve/updater.py
            echo "        s.listen()" >> /carve/updater.py
            echo "        while True:" >> /carve/updater.py
            echo "            conn, addr = s.accept()" >> /carve/updater.py
            echo "            with conn:" >> /carve/updater.py
            echo "                print('Connected by', addr)" >> /carve/updater.py
            echo "                while True:" >> /carve/updater.py
            echo "                    data = conn.recv(1024)" >> /carve/updater.py
            echo "                    if not data:" >> /carve/updater.py
            echo "                        break" >> /carve/updater.py
            echo "                    result = received(data)" >> /carve/updater.py
            echo "                    if result == 'success':" >> /carve/updater.py
            echo "                        conn.sendall(data)" >> /carve/updater.py
            echo "                    else:" >> /carve/updater.py
            echo "                        conn.sendall(bytes(result.encode()))" >> /carve/updater.py
            echo "" >> /carve/updater.py
            echo "def received(data):" >> /carve/updater.py
            echo "    try:" >> /carve/updater.py
            echo "        post = (json.loads(data))" >> /carve/updater.py
            echo "    except:" >> /carve/updater.py
            echo "        post = {}" >> /carve/updater.py
            echo "        result = 'socket did not receive json data'" >> /carve/updater.py
            echo "    # process based on json data" >> /carve/updater.py
            echo "    try:" >> /carve/updater.py
            echo "        if 'beacons' in post:" >> /carve/updater.py
            echo "            beacons = post['beacons'].split(',')" >> /carve/updater.py
            echo "            with open('new.cfg', 'a') as file:" >> /carve/updater.py
            echo "                for beacon in beacons:" >> /carve/updater.py
            echo "                    if valid_addr(beacon):" >> /carve/updater.py
            echo "                        file.write(f'{beacon}\n')" >> /carve/updater.py
            echo "                    else:" >> /carve/updater.py
            echo "                        pass" >> /carve/updater.py
            echo "            os.replace('new.cfg', 'carve.cfg')" >> /carve/updater.py
            echo "            result = 'success'" >> /carve/updater.py
            echo "        else:" >> /carve/updater.py
            echo "            result = f'beacons not in post: {post}'" >> /carve/updater.py
            echo "    except:" >> /carve/updater.py
            echo "        result = 'try exception'" >> /carve/updater.py
            echo "    return result" >> /carve/updater.py
            echo "" >> /carve/updater.py
            echo "def valid_addr(ipaddr):" >> /carve/updater.py
            echo "    # validate if string is a valid IP address" >> /carve/updater.py
            echo "    try:" >> /carve/updater.py
            echo "        ip = ipaddress.ip_address(ipaddr)" >> /carve/updater.py
            echo "        return True" >> /carve/updater.py
            echo "    except ValueError:" >> /carve/updater.py
            echo "        return False" >> /carve/updater.py
            echo "    except:" >> /carve/updater.py
            echo "        return False" >> /carve/updater.py
            echo "" >> /carve/updater.py
            echo "if __name__ == '__main__':" >> /carve/updater.py
            echo "    socket_server()" >> /carve/updater.py
            echo "
            # create carve testing script
            echo '#!/bin/bash' > /carve/carve.sh
            echo 'while true; do' >> /carve/carve.sh
            echo '  /sbin/fping -C 5 -i 1 -q -f /carve/carve.cfg &> /www/results-out' >> /carve/carve.sh
            echo '  mv -f /www/results-out /www/results' >> /carve/carve.sh
            echo '  date +%s > /www/ts-out' >> /carve/carve.sh
            echo '  mv -f /www/ts-out /www/ts' >> /carve/carve.sh
            echo '  sleep 10' >> /carve/carve.sh
            echo 'done' >> /carve/carve.sh
            chmod a+x /carve/carve.sh
            # run carve script continuous in the background
            /carve/carve.sh &
            # start update server to receive beacon address updates
            docker run -d --restart unless-stopped --name updater -p 8008:8008 -v "/carve:/carve" -w /carve python:slim python updater.py
            # All done so signal success
            # /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackId} --resource LaunchConfig --region ${AWS::Region} || echo 'cfn-signal error - stack is probably complete'

  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Carve EC2 ingress
      SecurityGroupIngress:
          # ingress to update beacon only from the Lambda SG
        - IpProtocol: "tcp"
          FromPort: 8008
          ToPort: 8008
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
          # ingress for beacon reults only from Lambda SG
        - IpProtocol: "tcp"
          FromPort: 80
          ToPort: 80
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
          # ICMP from everywhere else
        - IpProtocol: icmp
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref 'InstanceRole'

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${Prefix}carve-beacon-${VpcId}"
      Path: /
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal:
            Service:
              - "ec2.amazonaws.com"
          Action:
            - "sts:AssumeRole"

  EventInvokeLambda:
     Type: AWS::Lambda::Permission
     Properties:
       FunctionName: !Ref BridgeFunction
       Action: "lambda:InvokeFunction"
       Principal: "events.amazonaws.com"
       SourceArn: !GetAtt AsgEventRule.Arn

  AsgEventRule:
    Type: AWS::Events::Rule
    Properties:
      Description: "ASG notifications to BridgeFunction"
      EventPattern: 
        source:
          - "aws.autoscaling"
        detail-type:
          - "EC2 Instance Terminate Successful"
          - "EC2 Instance Launch Successful"
        detail:
          AutoScalingGroupName:
            - !Ref 'AutoScalingGroup'
      State: "ENABLED"
      Targets:
        - Id: "InvokeBridge"
          Arn: !GetAtt BridgeFunction.Arn

Outputs:
  AutoScalingGroup:
    Description: The name of the AutoScaling Group
    Value: !Ref 'AutoScalingGroup'

