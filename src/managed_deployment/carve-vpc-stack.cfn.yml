AWSTemplateFormatVersion: '2010-09-09'
Description: Carve VPC Testing Endpoint

Parameters:
  VpcId:
    Type: String
    Description: VPC ID in which the VPC Endpoint should be created
    Default: ""
  VpcSubnetIds:
    Type: String
    Description: one or more comma separated subnets in which to create endpoints
    Default: ""
  ResourcePrefix:
    Type: String
    Description: "Prefix all carve resources with this"
    Default: ""
  ImageId:
    Type: String
    Description: The ImageId from the Carve imagebuilder
    Default: ''
  CarveSNSTopicArn:
    Type: String
    Description: Carve SNS Topic Arn
  MinSize:
    Description: Minimum number of instances in the ASG
    Type: Number
    Default: '0'
  MaxSize:
    Description: Maximum number of instances in the ASG
    Type: Number
    Default: '1'
  DesiredSize:
    Description: Desored number of instances in the ASG
    Type: Number
    Default: '1'

Resources:
  Function:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CarveSubnetFunction
      Description: Continuous AWS Route Verification Engine
      Handler: index.lambda_handler
      Role: !GetAtt LambdaRole.Arn
      Runtime: python3.8
      Timeout: 20
      MemorySize: 128
      Environment:
        Variables:
          VpcSubnetIds: !Ref VpcSubnetIds
          VpcId: !Ref VpcId
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds: !Split [ ",", !Ref VpcSubnetIds ]
      Code: 
        ZipFile: !Sub |
          import urllib3
          import socket
          import json

          def hc(beacon):
              http = urllib3.PoolManager()
              try:
                response = http.request('GET', f'http://{beacon}/up')
                if r.status == 200:
                    result = 'up'
                else:
                    result = 'down'
              except:
                result = 'down'
              return result

          def get_results(beacon):
              http = urllib3.PoolManager()
              try:
                  r = http.request('GET', f'http://{beacon}/results')
                  ts = http.request('GET', f'http://{beacon}/ts')
                  if r.status == 200:
                      result = {'results': r.data, 'ts': ts.data}
                  else:
                      result = {'error': r.status, 'health': hc(beacon)}
              except Exception as e:
                  result = {'error': r.status, 'health': hc(beacon)}
              return result

          def update_beacon(beacon, beacons):
            config = json.dumps({'beacons': beacons}).encode()
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect((beacon, 8008))
                s.sendall(config)
                data = s.recv(1024)
            if data == config:
                print('beacon update successful')
            else:
                print(f'ERROR: beacon update confirmation failed for {beacon}')
                print(f'submitted: {config}')
                print(f'returned: {data}')

          def lambda_handler(event, context):
              if event['action'] == 'results':
                get_results(event['beacon'])
              elif event['action'] == 'update':
                update_beacon(event['beacon'], event['beacons'])


  LambdaRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal:
            Service:
              - "lambda.amazonaws.com"
          Action:
            - "sts:AssumeRole"

  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Carve Lambda Egress

  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    CreationPolicy:
      ResourceSignal:
        Timeout: PT5M
        Count: !Ref MinSize
    Properties:
      AutoScalingGroupName: !Sub ${ResourcePrefix}carve-beacon-asg-${VpcId}
      LaunchConfigurationName: !Ref LaunchConfig
      VPCZoneIdentifier: !Split [ ",", !Ref VpcSubnetIds ]
      HealthCheckGracePeriod: '60'
      HealthCheckType: EC2
      MinSize: !Ref MinSize
      MaxSize: !Ref MaxSize
      MetricsCollection:
        - Granularity: 1Minute
      Tags:
        - Key: Name
          Value: !Sub ${ResourcePrefix}carve-beacon-${VpcId}
          PropagateAtLaunch: true

  LaunchConfig:
    Type: AWS::AutoScaling::LaunchConfiguration
    Metadata:
      AWS::CloudFormation::Init:
        config:
          files:
            # get the carve config snippet from S3
            Fn::Transform:
              Name: AWS::Include
              Parameters:
                Location: s3://a-carve-managed-bucket-o-dvdaw54vmt-us-east-1/managed_deployment/carve-config.json
            # get the carve update python snippet from S3
            Fn::Transform:
              Name: AWS::Include
              Parameters:
                Location: s3://a-carve-managed-bucket-o-dvdaw54vmt-us-east-1/managed_deployment/carve-updater.yml
            # The cfn-hup.conf file stores the name of the stack and the AWS credentials that the cfn-hup daemon targets.
            "/etc/cfn/cfn-hup.conf":
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
                # The interval used to check for changes to the resource metadata in minutes. Default is 15
                interval=1
              mode: "000400"
              owner: "root"
              group: "root"
            # The user actions that the cfn-hup daemon calls periodically are defined in the hooks.conf configuration file.
            "/etc/cfn/hooks.d/cfn-auto-reloader.conf":
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.LaunchConfig.Metadata.AWS::CloudFormation::Init
                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource LaunchConfig --region ${AWS::Region}
              mode: "000400"
              owner: "root"
              group: "root"
    Properties:
      AssociatePublicIpAddress: 'true'
      SecurityGroups:
        - !Ref 'InstanceSecurityGroup'
      IamInstanceProfile: !Ref 'InstanceProfile'
      ImageId: !Ref 'ImageId'
      InstanceMonitoring: 'false'
      InstanceType: t4g.nano
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeType: gp2
            VolumeSize: '8'
            DeleteOnTermination: 'true'
            Encrypted: 'true'
      UserData:
        "Fn::Base64":
          !Sub |
            #!/bin/bash -xe
            # Start cfn-init
            /opt/aws/bin/cfn-init -s ${AWS::StackId} -r LaunchConfig --region ${AWS::Region} || error_exit 'Failed to run cfn-init'
            # Start up the cfn-hup daemon to listen for changes to the EC2 instance metadata
            /opt/aws/bin/cfn-hup || error_exit 'Failed to start cfn-hup'
            # create carve testing script
            echo '#!/bin/bash' > /carve/carve.sh
            echo 'while true; do' >> /carve/carve.sh
            echo '  /sbin/fping -C 5 -i 1 -q -f /carve/carve.cfg &> /www/results-out' >> /carve/carve.sh
            echo '  mv -f /www/results-out /www/results' >> /carve/carve.sh
            echo '  date +%s > /www/ts-out' >> /carve/carve.sh
            echo '  mv -f /www/ts-out /www/ts' >> /carve/carve.sh
            echo '  sleep 10' >> /carve/carve.sh
            echo 'done' >> /carve/carve.sh
            chmod a+x /carve/carve.sh
            # run carve script continuous in the background
            /carve/carve.sh &
            # start update server to receive beacon address updates
            docker run -d --restart unless-stopped --name updater -p 8008:8008 -v "/carve:/carve" -w /carve python:slim python updater.py
            # All done so signal success
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackId} --resource LaunchConfig --region ${AWS::Region} || echo 'cfn-signal error - stack is probably complete'

  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Carve EC2 ingress
      SecurityGroupIngress:
          # ingress to update beacon only from the Lambda SG
        - IpProtocol: "tcp"
          FromPort: 8008
          ToPort: 8008
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
          # ingress for beacon reults only from Lambda SG
        - IpProtocol: "tcp"
          FromPort: 80
          ToPort: 80
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
          # ICMP from everywhere else
        - IpProtocol: icmp
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref 'InstanceRole'

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${ResourcePrefix}carve-beacon-${VpcId}"
      Path: /
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal:
            Service:
              - "ec2.amazonaws.com"
          Action:
            - "sts:AssumeRole"

  EventRule:
    Type: AWS::Events::Rule
    Properties:
      Description: "ASG notifications to SNS"
      EventPattern: 
        source:
          - "aws.autoscaling"
        detail-type:
          - "EC2 Instance Terminate Successful"
          - "EC2 Instance Launch Successful"
        detail:
          AutoScalingGroupName:
            - !Ref 'AutoScalingGroup'
      State: "ENABLED"
      Targets:
        - Id: "SendSNStoCarve"
          Arn: 'arn:aws:sns:us-east-1:${AWS::AccountId}:a-carve-events'
  
Outputs:
  AutoScalingGroup:
    Description: The name of the AutoScaling Group
    Value: !Ref 'AutoScalingGroup'

