AWSTemplateFormatVersion: '2010-09-09'
Description: Carve VPC Testing Beacons

Parameters:
  VpcId:
    Type: String
    Description: VPC ID in which the beacons should be created
    Default: ""
  VpcSubnetIds:
    Type: String
    Description: one or more comma separated subnets in which to create beacons
    Default: ""
  Prefix:
    Type: String
    Description: "Prefix carve AWS resources and stacknames with this"
    Default: ""
  ImageId:
    Type: String
    Description: The ImageId from the Carve imagebuilder
    Default: ''
  CarveSNSTopicArn:
    Type: String
    Description: Carve SNS Topic
  MinSize:
    Description: Minimum number of instances in the ASG
    Type: Number
    Default: '0'
  MaxSize:
    Description: Maximum number of instances in the ASG
    Type: Number
    Default: '1'
  DesiredSize:
    Description: Desored number of instances in the ASG
    Type: Number
    Default: '1'

# Conditions:
#   UseOrgId: !Equals 
#     - !Ref "UniqueId"
#     - !Ref ""

Resources:
  BridgeFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${Prefix}carve-bridge-${VpcId}'
      Description: Bridge ASG Events Across Accounts and Regions with SNS
      Handler: index.lambda_handler
      Role: !GetAtt CarveLambdaRole.Arn
      Runtime: python3.8
      Timeout: 20
      MemorySize: 128
      Code: 
        ZipFile: !Sub |
          import boto3, os, json
          def lambda_handler(event, context):
              print(event)
              if 'source' in event:
                  if event['source'] == 'aws.autoscaling':
                      client = boto3.client('sns')
                      response = client.publish(
                          TopicArn="${CarveSNSTopicArn}",
                          Message=json.dumps(event))

  SubnetFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: CarveSubnetFunction
      Description: Continuous AWS Route Verification Engine
      Handler: index.lambda_handler
      Role: !GetAtt CarveLambdaRole.Arn
      Runtime: python3.8
      Timeout: 20
      MemorySize: 128
      Environment:
        Variables:
          VpcSubnetIds: !Ref VpcSubnetIds
          VpcId: !Ref VpcId
      VpcConfig:
        SecurityGroupIds:
          - !Ref LambdaSecurityGroup
        SubnetIds: !Split [ ",", !Ref VpcSubnetIds ]
      Code: 
        ZipFile: !Sub |
          import urllib3
          import socket
          import json

          def hc(beacon):
              http = urllib3.PoolManager()
              try:
                  r = http.request('GET', f'http://{beacon}/up', timeout=0.1)
                  if r.status == 200:
                      result = 'up'
                  else:
                      result = 'down'
              except:
                  result = 'down'
              return result

          def get_results(beacon):
              print(f'getting results for beacon: {beacon}')
              http = urllib3.PoolManager()
              result = None
              try:
                  r = http.request('GET', f'http://{beacon}/results', timeout=0.1)
                  ts = http.request('GET', f'http://{beacon}/ts', timeout=0.1)
                  if r.status == 200:
                      result = {'status': r.status, 'result': r.data, 'health': hc(beacon), 'ts': ts.data}
                  else:
                      result = {'status': r.status, 'result': 'error', 'health': hc(beacon)}
              except urllib3.exceptions.ConnectTimeoutError:
                  result = {'status': 'ConnectTimeoutError', 'result': 'timeout', 'health': hc(beacon)}
              except urllib3.exceptions.MaxRetryError:
                  result = {'status': 'MaxRetryError', 'result': 'timeout', 'health': hc(beacon)}
              except urllib3.exceptions.HTTPError as e:
                  result = {'status': 'HTTPError', 'result': 'timeout', 'health': hc(beacon)}
              print(result)
              return result

          def update_beacon(beacon, beacons):
              config = json.dumps({'beacons': beacons}).encode()
              with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                  s.connect((beacon, 8008))
                  s.sendall(config)
                  data = s.recv(1024)
              if data == config:
                  print('beacon update successful')
              else:
                  print(f'ERROR: beacon update confirmation failed for {beacon}')
                  print(f'submitted: {config}')
                  print(f'returned: {data}')

          def lambda_handler(event, context):
              print(event)
              if event['action'] == 'results':
                  result = get_results(event['beacon'])
              elif event['action'] == 'update':
                  result = update_beacon(event['beacon'], event['beacons'])
              return result


  CarveLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal:
            Service:
              - "lambda.amazonaws.com"
          Action:
            - "sts:AssumeRole"
      Policies:
        - PolicyName: CarveSNS
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "sns:Publish"
                Resource: !Ref CarveSNSTopicArn

  LambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Carve Lambda Egress

  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    CreationPolicy:
      ResourceSignal:
        Timeout: PT5M
        Count: !Ref MinSize
    Properties:
      AutoScalingGroupName: !Sub ${Prefix}carve-beacon-asg-${VpcId}
      LaunchConfigurationName: !Ref LaunchConfig
      VPCZoneIdentifier: !Split [ ",", !Ref VpcSubnetIds ]
      HealthCheckGracePeriod: '60'
      HealthCheckType: EC2
      MinSize: !Ref MinSize
      MaxSize: !Ref MaxSize
      MetricsCollection:
        - Granularity: 1Minute
      Tags:
        - Key: Name
          Value: !Sub ${Prefix}carve-beacon-${VpcId}
          PropagateAtLaunch: true

  LaunchConfig:
    Type: AWS::AutoScaling::LaunchConfiguration
    Metadata:
      AWS::CloudFormation::Init:
        config:
          files:
            # get the carve updater python code from S3 (the location below is replaced in code later)
            Fn::Transform:
              Name: AWS::Include
              Parameters:
                Location: s3://carve-managed-bucket/managed_deployment/carve-updater.yml
            # create the carve config file
            "/carve/carve.cfg":
              content: "0.0.0.0"
              mode: "000644"
              owner: "root"
              group: "root"                    
            # The cfn-hup.conf file stores the name of the stack and the AWS credentials that the cfn-hup daemon targets.
            "/etc/cfn/cfn-hup.conf":
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
                # The interval used to check for changes to the resource metadata in minutes. Default is 15
                interval=1
              mode: "000400"
              owner: "root"
              group: "root"
            # The user actions that the cfn-hup daemon calls periodically are defined in the hooks.conf configuration file.
            "/etc/cfn/hooks.d/cfn-auto-reloader.conf":
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.LaunchConfig.Metadata.AWS::CloudFormation::Init
                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource LaunchConfig --region ${AWS::Region}
              mode: "000400"
              owner: "root"
              group: "root"
    Properties:
      AssociatePublicIpAddress: 'false'
      SecurityGroups:
        - !Ref 'InstanceSecurityGroup'
      IamInstanceProfile: !Ref 'InstanceProfile'
      ImageId: !Ref 'ImageId'
      InstanceMonitoring: 'false'
      InstanceType: t4g.nano
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeType: gp2
            VolumeSize: '8'
            DeleteOnTermination: 'true'
            Encrypted: 'true'
      UserData:
        "Fn::Base64":
          !Sub |
            #!/bin/bash -xe
            # Start cfn-init
            /opt/aws/bin/cfn-init -s ${AWS::StackId} -r LaunchConfig --region ${AWS::Region} || error_exit 'Failed to run cfn-init'
            # Start up the cfn-hup daemon to listen for changes to the EC2 instance metadata
            /opt/aws/bin/cfn-hup || error_exit 'Failed to start cfn-hup'
            # create carve testing script
            echo '#!/bin/bash' > /carve/carve.sh
            echo 'while true; do' >> /carve/carve.sh
            echo '  /sbin/fping -C 5 -i 1 -q -f /carve/carve.cfg &> /www/results-out' >> /carve/carve.sh
            echo '  mv -f /www/results-out /www/results' >> /carve/carve.sh
            echo '  date +%s > /www/ts-out' >> /carve/carve.sh
            echo '  mv -f /www/ts-out /www/ts' >> /carve/carve.sh
            echo '  sleep 10' >> /carve/carve.sh
            echo 'done' >> /carve/carve.sh
            chmod a+x /carve/carve.sh
            # run carve script continuous in the background
            /carve/carve.sh &
            # start update server to receive beacon address updates
            docker run -d --restart unless-stopped --name updater -p 8008:8008 -v "/carve:/carve" -w /carve python:slim python updater.py
            # All done so signal success
            /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackId} --resource LaunchConfig --region ${AWS::Region} || echo 'cfn-signal error - stack is probably complete'

  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcId
      GroupDescription: Carve EC2 ingress
      SecurityGroupIngress:
          # ingress to update beacon only from the Lambda SG
        - IpProtocol: "tcp"
          FromPort: 8008
          ToPort: 8008
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
          # ingress for beacon reults only from Lambda SG
        - IpProtocol: "tcp"
          FromPort: 80
          ToPort: 80
          SourceSecurityGroupId: !Ref LambdaSecurityGroup
          # ICMP from everywhere else
        - IpProtocol: icmp
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref 'InstanceRole'

  InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${Prefix}carve-beacon-${VpcId}"
      Path: /
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
        - Effect: "Allow"
          Principal:
            Service:
              - "ec2.amazonaws.com"
          Action:
            - "sts:AssumeRole"

  EventInvokeLambda:
     Type: AWS::Lambda::Permission
     Properties:
       FunctionName: !Ref BridgeFunction
       Action: "lambda:InvokeFunction"
       Principal: "events.amazonaws.com"
       SourceArn: !GetAtt AsgEventRule.Arn

  AsgEventRule:
    Type: AWS::Events::Rule
    Properties:
      Description: "ASG notifications to BridgeFunction"
      EventPattern: 
        source:
          - "aws.autoscaling"
        detail-type:
          - "EC2 Instance Terminate Successful"
          - "EC2 Instance Launch Successful"
        detail:
          AutoScalingGroupName:
            - !Ref 'AutoScalingGroup'
      State: "ENABLED"
      Targets:
        - Id: "InvokeBridge"
          Arn: !GetAtt BridgeFunction.Arn

Outputs:
  AutoScalingGroup:
    Description: The name of the AutoScaling Group
    Value: !Ref 'AutoScalingGroup'

